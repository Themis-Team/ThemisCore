/*! 
  \file examples/generate_force_free_jet_image.cpp
  \author Paul Tiede
  \date Sept, 2018
  \brief Example illustrating the creation of a force free jet model.
  
  \details Themis allows a vast variety of models to be compared to
  EHT data. This example shows how to query the SED-fitted force free
  jet model using a fitted spectrum for M87.
  (an explicit model_image class), and generate an intrinsic image 
  for the best fit parameters in Broderick et al. (2016).  The output
  file, riaf_image.d, is in the standard pmap format and may be plotted
  with the python script vrt2_image.py via:

    $ python ../../analysis/plot_vrt2_images.py riaf_image.d

  The resulting image is shown below.

  \image html images/plots/sgra_bestfit.png "Image generated by plot_vrt2_image.py from the output pmap file."
*/

#include "model_image_force_free_jet.h"
#include <mpi.h>

int main(int argc, char* argv[])
{

  // Initialize MPI
  MPI_Init(&argc, &argv);
  int world_rank, world_size;
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);
  std::cout << "MPI Initiated in rank: " << world_rank << " of " << world_size << std::endl;

  //fit summaries files to be read in
  std::string fs_file = "";
  std::string outfile = "foo_ffj.dat";
  int nray = 32;
  int nrefine = 3;
  double fov= 160;

  for (int k=1; k<argc;)
  {
    std::string opt(argv[k++]);

    if (opt=="--fit-summaries" || opt=="-fs")
    {
      if (k<argc)
	fs_file = std::string(argv[k++]);
      else
      {
	if (world_rank==0)
	  std::cerr << "ERROR: A string argument must be provided after --fit-summaries, -fs.\n";
	std::exit(1);
      }
    }
    else if (opt=="--out")
    {
      if (k<argc)
	outfile = std::string(argv[k++]);
      else
      {
	if (world_rank==0)
	  std::cerr << "ERROR: An string argument must be provided after --out.\n";
	std::exit(1);
      }
    }
    else if (opt=="-n" || opt == "--nray")
    {
      if (k<argc)
	nray = atoi(argv[k++]);
      else
      {
	if (world_rank==0)
	  std::cerr << "ERROR: An int argument must be provided after -n.\n";
	std::exit(1);
      }
    }
    else if (opt=="-r" || opt == "--refines")
    {
      if (k<argc)
	nrefine = atoi(argv[k++]);
      else
      {
	if (world_rank==0)
	  std::cerr << "ERROR: An int argument must be provided after -r.\n";
	std::exit(1);
      }
    }
    else if (opt=="-fov" || opt == "--field-of-view")
    {
      if (k<argc)
	fov = atof(argv[k++]);
      else
      {
	if (world_rank==0)
	  std::cerr << "ERROR: An string argument must be provided after --out.\n";
	std::exit(1);
      }
    }
    else if (opt=="-h" || opt=="--help")
    {
      if (world_rank==0)
	std::cerr << "NAME\n"
		  << "\tDriver executable for FFJ model\n\n"
		  << "SYNOPSIS"
		  << "\tmpirun -np 2 ./generate_force_free_jet_image.cpp -fs image_params.txt [OPTIONS]\n\n"
		  << "REQUIRED OPTIONS\n"
		  << "\t-fs, --fit-summaries <string>\n"
		  << "\t\tSets the name of the file containing the ffj parameters.\n"
		  << "DESCRIPTION\n"
		  << "\t-h,--help\n"
		  << "\t\tPrint this message.\n"
		  << "\t--out <string>\n"
		  << "\t\tSets the name for the outputted pmap file,.\n"
                  << "\t\tDefaults to foo_ffj.dat\n"
                  << "\t-n, --nray\n"
                  << "\t\tSets the number of rays to use when creating the image.\n"
                  << "\t-r, --refines\n"
                  << "\t\tSets the number of refines to use when creating the image.\n"
                  << "\t-fov, --field-of-view\n"
                  << "\t\tSets the field of view in M for the image.\n";
      std::exit(0);
    }
    else
    {
      if (world_rank==0)
      {
	std::cerr << "ERROR: Unrecognized option " << opt << "\n";
	std::cerr << "Try -h or --help for options";
      }
      std::exit(1);
    }
  }  

  if (fs_file=="")
  {
    if (world_rank==0)
      std::cerr << "ERROR: No fit summaries file was provided. The -fs <string> options are *required*.\n"
		<< "  See -h for more details and options.\n";
    std::exit(1);
  }


  std::vector<double> parameters;

  std::fstream pfin(fs_file);
  if (!pfin.is_open())
  {
    std::cerr << "ERROR: Could not open " << fs_file << '\n';
    std::exit(1);
  }
  double dtmp;
  pfin.ignore(4096,'\n');
  // Get first index
  pfin >> dtmp;
  for (int k=0; k<14; k++)
  {
      pfin >> dtmp;
      parameters.push_back(dtmp);
  }
  // Kill remainder of line
  pfin.ignore(4096,'\n');

  
    std::cout << "ffj parameters list: (" << parameters.size() << ")\n";
    std::cout << "-------------------------------------------------\n" << std::endl;
    std::cout << "mass    :" << parameters[0] << std::endl
              << "distance:" << parameters[1] << std::endl
              << "spin    :" << parameters[2] << std::endl
              << "cosInc  :" << parameters[3] << std::endl
              << "rad_pl  :" << parameters[4] << std::endl
              << "op_ang  :" << parameters[5] << std::endl
              << "rLoad   :" << parameters[6] << std::endl
              << "G_inf   :" << parameters[7] << std::endl
              << "n_e     :" << parameters[8] << std::endl
              << "s_e     :" << parameters[9] << std::endl
              << "B0      :" << parameters[10] << std::endl
              << "gam_min :" << parameters[11] << std::endl
              << "inner_e :" << parameters[12] << std::endl
              << "posang  :" << parameters[13] << std::endl
              << std::endl;


  Themis::model_image_force_free_jet image(230e9);

  // Make a low-resolution image if that is more convenient.  Commenting this
  // line out makes the default resolution images.
  //image.use_small_images();
  image.set_image_resolution(nray, nrefine);
  image.set_screen_size(fov/2.0);
  image.generate_model(parameters);

  if (world_rank==0)
    image.output_image(outfile.c_str(), true);
  
  MPI_Finalize();

  return 0;
}


/*!
  \file examples/generate_riaf_image.cpp
  \details
  
  \code

  // Initialize MPI
  MPI_Init(&argc, &argv);

  // ../../src/VRT2/DataFiles/2010_combined_fit_parameters.d
  Themis::model_image_sed_fitted_riaf image("../../src/VRT2/DataFiles/2010_combined_fit_parameters.d");

  // Make a low-resolution image if that is more convenient.  Commenting this
  // line out makes the default resolution images.
  // image.use_small_images();
  
  // Choose a specific set of physical parameters at which to create an image.
  std::vector<double> parameters;
  parameters.push_back( 0.15 ); // Spin parameter (0-1)
  parameters.push_back( std::cos(60*M_PI/180.0) ); // Cos(Inclination)
  parameters.push_back( 0.0 ); // Position angle (which doesn't impact the intrinsic image).

  // Generate a model.
  image.generate_model(parameters);

  // Access the image data (not usually required)
  std::vector<std::vector<double> > alpha, beta, I;
  image.get_image(alpha,beta,I);

  // Convert from radians to projected GM/c^2 just for convenience
  double rad2M = VRT2::VRT2_Constants::D_SgrA_cm/VRT2::VRT2_Constants::M_SgrA_cm;
  
  // Return the image (not usually required) and output it to a file in the
  // standard pmap format -- a rastered array of ASCII values with the limits
  // and dimensions at the top.
  std::ofstream imout("riaf_image.d");
  imout << "Nx:"
	<< std::setw(15) << rad2M*alpha[0][0]
	<< std::setw(15) << rad2M*alpha[alpha.size()-1].back()
	<< std::setw(15) << alpha.size()
	<< '\n';
  imout << "Ny:"
	<< std::setw(15) << rad2M*beta[0][0]
	<< std::setw(15) << rad2M*beta[beta.size()-1].back()
	<< std::setw(15) << beta.size()
	<< '\n';
  imout << std::setw(5) << "i"
	<< std::setw(5) << "j"
	<< std::setw(15) << "I (Jy/sr)"
	<< '\n';
  for (size_t j=0; j<alpha[0].size(); ++j)
    for (size_t i=0; i<alpha.size(); ++i)
      imout << std::setw(5) << i
	    << std::setw(5) << j
	    << std::setw(15) << I[i][j]
	    << '\n';
  
  // Finalize MPI
  MPI_Finalize();

  return 0;
  
  \endcode
*/


